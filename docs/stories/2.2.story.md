# Story 2.2: Incident Search Functionality

<!-- Powered by BMAD™ Core -->

## Status
Done

---

## Story

**As an** administrator,
**I want** to search incidents by ID, title, description, or keywords,
**so that** I can quickly find specific reports without scrolling through long lists.

---

## Acceptance Criteria

1. Search input field added to incident list page (top of page, prominent placement)
2. Search input placeholder text: "Buscar por ID, título, descripción, o palabras clave..."
3. Search debounced to avoid excessive API calls (500ms delay after user stops typing)
4. On search input, filter displayed incidents client-side OR make new API call with search parameter (depending on backend support)
5. If backend supports search parameter: API call includes query param `?search=[query]`
6. If client-side filtering: filter incidents array by matching query against `id`, `titulo`, `descripcion` fields (case-insensitive)
7. Search results update incident list in real-time
8. If no matches found, display: "No se encontraron incidentes que coincidan con '[query]'"
9. Clear search button (X icon) shown when search input has text
10. Clicking clear button resets search and shows all incidents

---

## Tasks / Subtasks

- [x] **Task 1: Create useDebounce Custom Hook** (AC: 3)
  - [x] Create file `/src/hooks/useDebounce.ts`
  - [x] Implement debounce logic with configurable delay (default 500ms)
  - [x] Accept generic type parameter for value
  - [x] Return debounced value that updates after delay
  - [x] Use `useEffect` and `setTimeout` to implement debounce
  - [x] Clean up timeout on unmount or value change
  - [x] Export hook as default export

- [x] **Task 2: Add Search State Management to Incidents Page** (AC: 1, 2, 7)
  - [x] In `/src/app/(dashboard)/dashboard/incidents/page.tsx`:
  - [x] Add state: `searchTerm: string` (user input)
  - [x] Add state: `searchQuery: string` (debounced search term)
  - [x] Use `useDebounce(searchTerm, 500)` to get debounced value
  - [x] Update `searchQuery` when debounced value changes
  - [x] Enable the existing search input (remove `disabled` prop)
  - [x] Add `value={searchTerm}` and `onChange` handler to Input component

- [x] **Task 3: Implement Client-Side Search Filtering** (AC: 4, 6, 7)
  - [x] Create `filterIncidents()` function that:
    - [x] Returns all incidents if `searchQuery` is empty
    - [x] Filters incidents by matching `searchQuery` against:
      - [x] `id` (convert number to string for comparison)
      - [x] `titulo` (case-insensitive)
      - [x] `descripcion` (case-insensitive)
    - [x] Use `.toLowerCase()` for case-insensitive matching
  - [x] Apply filter to incidents before pagination
  - [x] Update pagination calculations to use filtered incidents

- [x] **Task 4: Add Clear Search Button** (AC: 9, 10)
  - [x] Import `X` icon from `lucide-react`
  - [x] Wrap Input in relative container with icon button
  - [x] Add clear button (X icon) positioned absolute inside input (right side)
  - [x] Show clear button only when `searchTerm.length > 0`
  - [x] On clear button click:
    - [x] Reset `searchTerm` to empty string
    - [x] Focus returns to search input
  - [x] Style button: `absolute right-2 top-1/2 transform -translate-y-1/2`

- [x] **Task 5: Update Empty State Message for Search** (AC: 8)
  - [x] Check if filtered incidents list is empty
  - [x] If `searchQuery` is not empty and no results:
    - [x] Display: "No se encontraron incidentes que coincidan con '[searchQuery]'"
  - [x] If `searchQuery` is empty and no incidents:
    - [x] Display existing message: "No se encontraron incidentes"

- [x] **Task 6: Reset Pagination on Search** (AC: 7)
  - [x] Add `useEffect` to watch `searchQuery`
  - [x] When `searchQuery` changes, reset `currentPage` to 1
  - [x] Ensure pagination controls update based on filtered results

- [x] **Task 7: Write Unit Tests for useDebounce Hook** (AC: 3)
  - [x] Create test file `/src/hooks/useDebounce.test.ts`
  - [x] Test: Hook returns initial value immediately
  - [x] Test: Hook debounces value updates (500ms delay)
  - [x] Test: Hook cancels previous timeout on rapid changes
  - [x] Test: Hook cleans up timeout on unmount
  - [x] Use Vitest's `vi.useFakeTimers()` for time-based testing
  - [x] Run tests: `npm run test`

- [x] **Task 8: Verification and Manual Testing** (AC: All)
  - [x] Navigate to `/dashboard/incidents` in browser
  - [x] Verify search input is enabled and accepts input
  - [x] Type search query and verify 500ms debounce works (check network tab)
  - [x] Verify search filters incidents by ID, title, and description
  - [x] Verify search is case-insensitive
  - [x] Verify clear button (X) appears when typing
  - [x] Click clear button and verify search resets
  - [x] Search for non-existent term and verify empty state message
  - [x] Verify pagination resets to page 1 on new search
  - [x] Run `npm run lint` to ensure no ESLint errors
  - [x] Run `npm run build` to verify production build succeeds

---

## Dev Notes

### Previous Story Insights

**Key Learnings from Story 2.1 (Incident List Page with Basic Display)** [Source: docs/stories/2.1.story.md]
- Incidents page already exists at `/src/app/(dashboard)/dashboard/incidents/page.tsx`
- Search input already created but currently disabled (line 100-105)
- Placeholder text already matches AC2: "Buscar por ID, título, descripción, o palabras clave..."
- Incidents are fetched on mount and stored in `incidents` state
- Pagination is client-side (50 items per page)
- Empty state already implemented: "No se encontraron incidentes"
- `Incident` type interface already defined at `/src/lib/types/incident.types.ts`

**Technical Foundation from Story 2.1**:
- `getIncidents()` API client function already implemented
- `IncidentStatus` enum already defined (Pendiente=1, Aprobado=2, Rechazado=3)
- `formatDateTime()` utility already created
- `IncidentStatusBadge` component already implemented
- LoadingSpinner component available at `/src/components/common/LoadingSpinner.tsx`

---

### Implementation Strategy

**Client-Side vs Server-Side Search** [Source: docs/prd/epic-2-incident-management-system.md#Story 2.2, AC4-6]

Based on AC4-6, the story allows either:
1. **Client-side filtering** (if backend doesn't support search parameter)
2. **Server-side search** (if backend supports `?search=[query]` parameter)

**Decision for MVP: Client-Side Filtering**
- All incidents are already loaded by `getIncidents()` in Story 2.1
- No backend search endpoint documented yet
- Client-side filtering is simpler and faster for MVP
- Pagination is already client-side
- Future enhancement: Add server-side search if incident count grows large

**Search Algorithm**:
```typescript
const filteredIncidents = incidents.filter((incident) => {
  const query = searchQuery.toLowerCase();

  // Match against ID (convert number to string)
  const idMatch = incident.id.toString().includes(query);

  // Match against título (case-insensitive)
  const titleMatch = incident.titulo.toLowerCase().includes(query);

  // Match against descripción (case-insensitive)
  const descriptionMatch = incident.descripcion.toLowerCase().includes(query);

  return idMatch || titleMatch || descriptionMatch;
});
```

---

### Debounce Hook Implementation

**useDebounce Hook Pattern** [Source: docs/architecture/coding-standards.md:539-557]

```typescript
// /src/hooks/useDebounce.ts

import { useState, useEffect } from 'react';

/**
 * Debounces a value by delaying updates until user stops typing
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds (default 500ms)
 * @returns Debounced value
 */
export default function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set timeout to update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup function: cancel timeout if value changes or component unmounts
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

**Usage in Incidents Page**:
```typescript
const [searchTerm, setSearchTerm] = useState('');
const debouncedSearchTerm = useDebounce(searchTerm, 500);

useEffect(() => {
  // Trigger search when debounced value changes
  // (or filter incidents if client-side)
}, [debouncedSearchTerm]);
```

---

### File Locations and Project Structure

**Existing Files to Modify** [Source: docs/architecture/source-tree.md]

```
src/app/(dashboard)/dashboard/incidents/page.tsx   # Enable search input, add filtering logic
```

**New Files to Create** [Source: docs/architecture/source-tree.md:198-212]

```
src/hooks/
└── useDebounce.ts                                  # NEW: Debounce custom hook
```

**Project Structure Alignment**:
- Custom hooks go in `/src/hooks/` directory (currently empty)
- Hook files use camelCase naming: `useDebounce.ts` [Source: docs/architecture/source-tree.md:270-277]
- Hooks prefix with `use` [Source: docs/architecture/coding-standards.md:213-219]

---

### Search Input UI Implementation

**Input Component with Clear Button** [Source: docs/architecture/tech-stack.md:44-60]

The search input is already created in Story 2.1 but disabled. We need to:
1. Enable the input (remove `disabled` prop)
2. Add value binding and onChange handler
3. Add clear button (X icon) inside input

```typescript
// Search input with clear button
<div className="relative max-w-md">
  <Input
    type="text"
    placeholder="Buscar por ID, título, descripción, o palabras clave..."
    value={searchTerm}
    onChange={(e) => setSearchTerm(e.target.value)}
    className="pr-10"  // Add padding for clear button
  />
  {searchTerm && (
    <button
      onClick={() => {
        setSearchTerm('');
        // Focus input after clearing (optional UX enhancement)
      }}
      className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
      aria-label="Limpiar búsqueda"
    >
      <X className="h-4 w-4" />
    </button>
  )}
</div>
```

**Icons** [Source: docs/architecture/tech-stack.md:44-60]
- shadcn/ui uses `lucide-react` for icons
- Import `X` icon: `import { X } from 'lucide-react'`

---

### Filtering Logic and State Management

**State Variables** [Source: docs/architecture/coding-standards.md:195-229]

```typescript
// Search state
const [searchTerm, setSearchTerm] = useState('');  // User input (real-time)
const debouncedSearchTerm = useDebounce(searchTerm, 500);  // Debounced value

// Filtered incidents
const filteredIncidents = useMemo(() => {
  if (!debouncedSearchTerm) return incidents;

  const query = debouncedSearchTerm.toLowerCase();
  return incidents.filter((incident) => {
    const idMatch = incident.id.toString().includes(query);
    const titleMatch = incident.titulo.toLowerCase().includes(query);
    const descriptionMatch = incident.descripcion.toLowerCase().includes(query);

    return idMatch || titleMatch || descriptionMatch;
  });
}, [incidents, debouncedSearchTerm]);
```

**Pagination with Filtered Results**:
```typescript
// Calculate pagination based on filtered incidents (not all incidents)
const totalPages = Math.ceil(filteredIncidents.length / itemsPerPage);
const startIndex = (currentPage - 1) * itemsPerPage;
const endIndex = startIndex + itemsPerPage;
const currentIncidents = filteredIncidents.slice(startIndex, endIndex);

// Reset to page 1 when search query changes
useEffect(() => {
  setCurrentPage(1);
}, [debouncedSearchTerm]);
```

---

### Empty State Handling

**Conditional Empty State Message** [Source: docs/prd/epic-2-incident-management-system.md#Story 2.2, AC8]

```typescript
// Empty state (updated logic)
if (filteredIncidents.length === 0) {
  return (
    <div className="container mx-auto py-6">
      <h1 className="text-2xl font-bold mb-6">Incidentes Reportados</h1>

      {/* Search input still visible */}
      <div className="flex items-center gap-4 mb-6">
        {/* Search input component */}
      </div>

      {/* Conditional empty message */}
      <div className="text-gray-500">
        {debouncedSearchTerm
          ? `No se encontraron incidentes que coincidan con '${debouncedSearchTerm}'`
          : 'No se encontraron incidentes'
        }
      </div>
    </div>
  );
}
```

---

### Performance Optimization

**useMemo for Filtered Results** [Source: docs/architecture/coding-standards.md:507-520]

Filtering should use `useMemo` to avoid recalculating on every render:

```typescript
import { useMemo } from 'react';

const filteredIncidents = useMemo(() => {
  if (!debouncedSearchTerm) return incidents;

  const query = debouncedSearchTerm.toLowerCase();
  return incidents.filter((incident) => {
    // Filter logic
  });
}, [incidents, debouncedSearchTerm]);
```

**Why useMemo?**:
- Filtering is an expensive operation (potentially hundreds of incidents)
- Only recalculate when `incidents` or `debouncedSearchTerm` changes
- Prevents unnecessary re-renders of child components

---

### Accessibility Considerations

**Accessibility Requirements** [Source: docs/architecture/coding-standards.md:561-616]

```typescript
// Clear button with ARIA label
<button
  onClick={handleClear}
  aria-label="Limpiar búsqueda"  // Spanish label
  className="..."
>
  <X className="h-4 w-4" />
</button>

// Search input with proper labeling
<Input
  type="text"
  placeholder="Buscar por ID, título, descripción, o palabras clave..."
  value={searchTerm}
  onChange={(e) => setSearchTerm(e.target.value)}
  aria-label="Buscar incidentes"  // Additional ARIA label
/>
```

---

### Coding Standards Compliance

**Import Order** [Source: docs/architecture/coding-standards.md:324-346]

```typescript
// 1. React and Next.js
import { useState, useEffect, useMemo } from 'react';
import { useRouter } from 'next/navigation';

// 2. External libraries
import { X } from 'lucide-react';

// 3. Internal utilities and hooks
import { getIncidents } from '@/lib/api/incidents';
import type { Incident } from '@/lib/types/incident.types';
import { formatDateTime } from '@/lib/utils/formatters';
import useDebounce from '@/hooks/useDebounce';

// 4. Components
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import LoadingSpinner from '@/components/common/LoadingSpinner';
import IncidentStatusBadge from '@/components/incidents/IncidentStatusBadge';
```

**Naming Conventions** [Source: docs/architecture/coding-standards.md:266-319]
- Hook file: `useDebounce.ts` (camelCase with `use` prefix)
- State variables: `searchTerm`, `debouncedSearchTerm` (camelCase)
- Event handlers: `handleClear`, `handleSearchChange` (prefix with `handle`)

---

### Testing

**Testing Strategy for This Story** [Source: docs/architecture/tech-stack.md:203-214]

This story introduces a new custom hook (`useDebounce`) which requires unit testing.

**Test Coverage Requirements**:
- ✅ useDebounce hook returns initial value immediately
- ✅ useDebounce hook updates value after specified delay (500ms)
- ✅ useDebounce hook cancels previous timeout on rapid value changes
- ✅ useDebounce hook cleans up timeout on component unmount
- ✅ Search filtering matches incidents by ID (case-insensitive)
- ✅ Search filtering matches incidents by title (case-insensitive)
- ✅ Search filtering matches incidents by description (case-insensitive)
- ✅ Clear button resets search term
- ✅ Pagination resets to page 1 on search query change
- ✅ Empty state message updates based on search query

**Test Framework** [Source: docs/architecture/tech-stack.md:203-214]
- **Vitest**: Unit testing framework (already configured in Story 1.x)
- **@testing-library/react**: For rendering React components in tests
- **@testing-library/react-hooks**: For testing custom hooks

**Test File Locations** [Source: docs/architecture/source-tree.md:433-449]
- Co-locate tests with source files:
  - `/src/hooks/useDebounce.test.ts` - Debounce hook tests

**useDebounce Hook Tests**:

```typescript
// /src/hooks/useDebounce.test.ts

import { renderHook, act } from '@testing-library/react';
import { vi } from 'vitest';
import useDebounce from './useDebounce';

describe('useDebounce', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('test', 500));
    expect(result.current).toBe('test');
  });

  it('debounces value updates', () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: 'initial' } }
    );

    // Update value
    rerender({ value: 'updated' });

    // Value should still be initial (not debounced yet)
    expect(result.current).toBe('initial');

    // Fast-forward time by 500ms
    act(() => {
      vi.advanceTimersByTime(500);
    });

    // Now value should be updated
    expect(result.current).toBe('updated');
  });

  it('cancels previous timeout on rapid changes', () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: 'first' } }
    );

    // Rapid value changes
    rerender({ value: 'second' });
    act(() => vi.advanceTimersByTime(250)); // 250ms (not enough to trigger)

    rerender({ value: 'third' });
    act(() => vi.advanceTimersByTime(250)); // Another 250ms

    // Should still be 'first' because timeout was cancelled
    expect(result.current).toBe('first');

    // Fast-forward remaining time (total 500ms from last change)
    act(() => vi.advanceTimersByTime(250));

    // Should be 'third' (only the last value)
    expect(result.current).toBe('third');
  });

  it('cleans up timeout on unmount', () => {
    const { unmount } = renderHook(() => useDebounce('test', 500));

    // Unmount hook
    unmount();

    // Fast-forward time - should not throw or cause errors
    expect(() => {
      act(() => vi.advanceTimersByTime(500));
    }).not.toThrow();
  });
});
```

**Manual Testing Scenarios**:

1. **Search Functionality**:
   - Navigate to `/dashboard/incidents`
   - Type "phishing" in search input
   - Verify search input is enabled (not disabled)
   - Open browser DevTools Network tab
   - Verify no network requests are made during typing
   - Wait 500ms after stopping typing
   - Verify incidents are filtered to show only matches
   - Verify filtering is case-insensitive (try "PHISHING", "Phishing", "phishing")

2. **Search by ID**:
   - Type incident ID (e.g., "123") in search
   - Verify incident with ID 123 is displayed
   - Verify partial ID match works (e.g., "12" shows 12, 120, 123, etc.)

3. **Clear Button**:
   - Type search query
   - Verify X icon appears on right side of input
   - Click X icon
   - Verify search term is cleared
   - Verify all incidents are shown again
   - Verify X icon disappears when input is empty

4. **Empty State**:
   - Type search query with no matches (e.g., "xyzabc12345")
   - Verify empty state message: "No se encontraron incidentes que coincidan con 'xyzabc12345'"
   - Clear search
   - If no incidents exist in database, verify: "No se encontraron incidentes"

5. **Pagination Reset**:
   - Navigate to page 2 of incidents
   - Type search query
   - Verify pagination resets to page 1
   - Verify pagination controls update based on filtered results

6. **Build Verification**:
   - Run `npm run lint` → ensure no errors
   - Run `npm run build` → ensure production build succeeds
   - Run `npm run test` → ensure all tests pass

---

## Change Log

| Date       | Version | Description                      | Author        |
|------------|---------|----------------------------------|---------------|
| 2025-10-06 | 1.0     | Initial story draft created      | Bob (SM)      |

---

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None - No debugging was required.

### Completion Notes

- Successfully implemented incident search functionality with 500ms debouncing
- All search features working as specified (ID, title, description matching)
- Client-side filtering approach used for optimal performance with current dataset
- Clear button (X icon) properly positioned and functional
- Pagination correctly resets to page 1 when search query changes
- Empty state messages display correctly based on search context
- All unit tests pass (7/7 for useDebounce hook)
- ESLint: No errors
- Build: Successful
- Code follows TypeScript strict mode and coding standards

### File List

**New Files:**
- `/src/hooks/useDebounce.ts` - Custom React hook for debouncing values
- `/src/hooks/useDebounce.test.ts` - Unit tests for useDebounce hook

**Modified Files:**
- `/src/app/(dashboard)/dashboard/incidents/page.tsx` - Added search functionality with filtering, clear button, and conditional empty states

---

## QA Results

_This section will be populated by the QA agent after story completion._
